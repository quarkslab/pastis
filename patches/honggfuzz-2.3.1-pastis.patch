diff -ruN honggfuzz-2.3.1/cmdline.c honggfuzz-2.3.1-pastis/cmdline.c
--- honggfuzz-2.3.1/cmdline.c	2020-07-22 18:04:55.000000000 -0300
+++ honggfuzz-2.3.1-pastis/cmdline.c	2022-01-03 10:47:24.312085048 -0300
@@ -519,6 +519,8 @@
         { { "only_printable", no_argument, NULL, 0x10D }, "Only generate printable inputs" },
         { { "export_feedback", no_argument, NULL, 0x10E }, "Export the coverage feedback structure as ./hfuzz-feedback" },
         { { "const_feedback", required_argument, NULL, 0x112 }, "Use constant integer/string values from fuzzed programs to mangle input files via a dynamic dictionary (default: true)" },
+        { { "statsfile", required_argument, NULL, 0x113 }, "Stats file" },
+        { { "dynamic_input", required_argument, NULL, 0x114 }, "Path to a directory containing the dynamic file corpus" },
 
 #if defined(_HF_ARCH_LINUX)
         { { "linux_symbols_bl", required_argument, NULL, 0x504 }, "Symbols blacklist filter file (one entry per line)" },
@@ -639,6 +641,12 @@
             case 0x112:
                 hfuzz->feedback.cmpFeedback = cmdlineParseTrueFalse(opts[opt_index].name, optarg);
                 break;
+            case 0x113:
+                hfuzz->io.statsFileName = optarg;
+                break;
+            case 0x114:
+                hfuzz->io.dynamicInputDir = optarg;
+                break;
             case 'z':
                 hfuzz->feedback.dynFileMethod |= _HF_DYNFILE_SOFT;
                 break;
diff -ruN honggfuzz-2.3.1/fuzz.c honggfuzz-2.3.1-pastis/fuzz.c
--- honggfuzz-2.3.1/fuzz.c	2020-07-22 18:04:55.000000000 -0300
+++ honggfuzz-2.3.1-pastis/fuzz.c	2021-09-24 11:26:54.598025953 -0300
@@ -234,6 +234,40 @@
         run->dynfile->cov[1] = softCurCmp;
         run->dynfile->cov[2] = run->hwCnts.cpuInstrCnt + run->hwCnts.cpuBranchCnt;
         run->dynfile->cov[3] = run->dynfile->size ? (64 - util_Log2(run->dynfile->size)) : 64;
+
+        if (run->global->io.statsFileName) {
+            /* NOTE: Calculation of `tot_exec_per_sec` taken from
+             * the `display_display` function.
+             */
+            const time_t curr_sec = time(NULL);
+            const time_t elapsed_sec = curr_sec - run->global->timing.timeStart;
+            size_t curr_exec_cnt = ATOMIC_GET(run->global->cnts.mutationsCnt);
+            /*
+             * We increase the mutation counter unconditionally in threads, but if it's
+             * above hfuzz->mutationsMax we don't really execute the fuzzing loop.
+             * Therefore at the end of fuzzing, the mutation counter might be higher
+             * than hfuzz->mutationsMax
+             */
+            if (run->global->mutate.mutationsMax > 0 && curr_exec_cnt > run->global->mutate.mutationsMax) {
+                curr_exec_cnt = run->global->mutate.mutationsMax;
+            }
+            size_t tot_exec_per_sec = elapsed_sec ? (curr_exec_cnt / elapsed_sec) : 0;
+
+            dprintf(run->global->io.statsFileFd,
+                "%lu, %lu, %lu, %lu, "
+                "%" PRIu64 ", %" PRIu64 ", %" PRIu64 ", %" PRIu64 ", %" PRIu64 "\n",
+                curr_sec,                                               /* unix_time */
+                ATOMIC_GET(run->global->timing.lastCovUpdate),          /* last_cov_update */
+                curr_exec_cnt,                                          /* total_exec */
+                tot_exec_per_sec,                                       /* exec_per_sec */
+                ATOMIC_GET(run->global->cnts.crashesCnt),               /* crashes */
+                ATOMIC_GET(run->global->cnts.uniqueCrashesCnt),         /* unique_crashes */
+                ATOMIC_GET(run->global->cnts.timeoutedCnt),             /* hangs */
+                ATOMIC_GET(run->global->feedback.hwCnts.softCntEdge),      /* edge_cov */
+                ATOMIC_GET(run->global->feedback.hwCnts.softCntPc)         /* block_cov */
+            );
+        }
+
         input_addDynamicInput(run);
 
         if (run->global->socketFuzzer.enabled) {
diff -ruN honggfuzz-2.3.1/honggfuzz.c honggfuzz-2.3.1-pastis/honggfuzz.c
--- honggfuzz-2.3.1/honggfuzz.c	2020-07-22 18:04:55.000000000 -0300
+++ honggfuzz-2.3.1-pastis/honggfuzz.c	2021-09-24 11:26:54.602025931 -0300
@@ -33,6 +33,9 @@
 #include <time.h>
 #include <unistd.h>
 
+#include <fcntl.h>
+#include <sys/stat.h>
+
 #include "cmdline.h"
 #include "display.h"
 #include "fuzz.h"
@@ -260,6 +263,12 @@
     setupMainThreadTimer();
 
     for (;;) {
+      /* Dynamic input queue. */
+      if (hfuzz->io.dynamicInputDir) {
+          LOG_D("Loading files from the dynamic input queue...");
+          input_enqueueDynamicInputs(hfuzz);
+      }
+
         if (hfuzz->display.useScreen) {
             if (ATOMIC_XCHG(clearWin, false)) {
                 display_clear();
@@ -298,7 +307,7 @@
 }
 
 static const char* getGitVersion() {
-    static char version[] = "$Id: 26017da9da354ef4480d11fe3468f4622fb25223 $";
+    static char version[] = "$Id: 1922156f08f9fcd146f0f2f59a527c1e6ba7dbc4 $";
     if (strlen(version) == 47) {
         version[45] = '\0';
         return &version[5];
@@ -395,6 +404,17 @@
         }
     }
 
+    /* Stats file. */
+    if (hfuzz.io.statsFileName) {
+        hfuzz.io.statsFileFd = TEMP_FAILURE_RETRY(open(hfuzz.io.statsFileName, O_CREAT | O_RDWR | O_TRUNC, 0640));
+
+        if (hfuzz.io.statsFileFd == -1) {
+            PLOG_F("Couldn't open statsfile open('%s')", hfuzz.io.statsFileName);
+        } else {
+            dprintf(hfuzz.io.statsFileFd, "# unix_time, last_cov_update, total_exec, exec_per_sec, crashes, unique_crashes, hangs, edge_cov, block_cov\n");
+        }
+    }
+
     setupRLimits();
     setupSignalsPreThreads();
     fuzz_threadsStart(&hfuzz);
@@ -429,6 +449,11 @@
         cleanupSocketFuzzer();
     }
 
+    /* Stats file. */
+    if (hfuzz.io.statsFileName) {
+        close(hfuzz.io.statsFileFd);
+    }
+
     printSummary(&hfuzz);
 
     return EXIT_SUCCESS;
diff -ruN honggfuzz-2.3.1/honggfuzz.h honggfuzz-2.3.1-pastis/honggfuzz.h
--- honggfuzz-2.3.1/honggfuzz.h	2020-07-22 18:04:55.000000000 -0300
+++ honggfuzz-2.3.1-pastis/honggfuzz.h	2021-09-24 11:26:54.602025931 -0300
@@ -214,6 +214,9 @@
         dynfile_t*  dynfileq2Current;
         TAILQ_HEAD(dyns_t, _dynfile_t) dynfileq;
         bool exportFeedback;
+        const char* statsFileName;
+        int statsFileFd;
+        const char* dynamicInputDir;
     } io;
     struct {
         int                argc;
diff -ruN honggfuzz-2.3.1/input.c honggfuzz-2.3.1-pastis/input.c
--- honggfuzz-2.3.1/input.c	2020-07-22 18:04:55.000000000 -0300
+++ honggfuzz-2.3.1-pastis/input.c	2021-09-24 11:26:54.614025866 -0300
@@ -35,6 +35,8 @@
 #include <sys/stat.h>
 #include <unistd.h>
 
+#include <sys/mman.h>
+
 #include "fuzz.h"
 #include "libhfcommon/common.h"
 #include "libhfcommon/files.h"
@@ -567,6 +569,129 @@
     return true;
 }
 
+/**
+ * NOTE: This function is based on `input_getNext`.
+ */
+bool input_dynamicQueueGetNext(char fname[PATH_MAX], DIR* dynamicDirPtr, char *dynamicWorkDir) {
+    static pthread_mutex_t input_mutex = PTHREAD_MUTEX_INITIALIZER;
+    MX_SCOPED_LOCK(&input_mutex);
+
+    for (;;) {
+        errno = 0;
+        struct dirent* entry = readdir(dynamicDirPtr);
+        if (entry == NULL && errno == EINTR) {
+            continue;
+        }
+        if (entry == NULL && errno != 0) {
+            PLOG_W("readdir_r('%s')", dynamicWorkDir);
+            return false;
+        }
+        if (entry == NULL) {
+            return false;
+        }
+        char path[PATH_MAX];
+        snprintf(path, PATH_MAX, "%s/%s", dynamicWorkDir, entry->d_name);
+        struct stat st;
+        if (stat(path, &st) == -1) {
+            LOG_W("Couldn't stat() the '%s' file", path);
+            continue;
+        }
+        if (!S_ISREG(st.st_mode)) {
+            LOG_D("'%s' is not a regular file, skipping", path);
+            continue;
+        }
+
+        snprintf(fname, PATH_MAX, "%s/%s", dynamicWorkDir, entry->d_name);
+        return true;
+    }
+}
+
+void input_enqueueDynamicInputs(honggfuzz_t* hfuzz) {
+    char dynamicWorkDir[PATH_MAX];
+
+    snprintf(dynamicWorkDir, sizeof(dynamicWorkDir), "%s", hfuzz->io.dynamicInputDir);
+
+    int dynamicDirFd = TEMP_FAILURE_RETRY(open(dynamicWorkDir, O_DIRECTORY | O_RDONLY | O_CLOEXEC));
+    if (dynamicDirFd == -1) {
+        PLOG_W("open('%s', O_DIRECTORY|O_RDONLY|O_CLOEXEC)", dynamicWorkDir);
+        return;
+    }
+
+    DIR* dynamicDirPtr;
+    if ((dynamicDirPtr = fdopendir(dynamicDirFd)) == NULL) {
+        PLOG_W("fdopendir(dir='%s', fd=%d)", dynamicWorkDir, dynamicDirFd);
+        close(dynamicDirFd);
+        return;
+    }
+
+    char dynamicInputFileName[PATH_MAX];
+    for (;;) {
+        if (!input_dynamicQueueGetNext(dynamicInputFileName, dynamicDirPtr, dynamicWorkDir)) {
+            break;
+        }
+
+        int dynamicFileFd;
+        if ((dynamicFileFd = open(dynamicInputFileName, O_RDWR)) == -1) {
+            PLOG_E("Error opening dynamic input file: %s", dynamicInputFileName);
+            continue;
+        }
+
+        /* Get file status. */
+        struct stat dynamicFileStat;
+        size_t dynamicFileSz;
+
+        if (fstat(dynamicFileFd, &dynamicFileStat) == -1) {
+            PLOG_E("Error getting file status: %s", dynamicInputFileName);
+            close(dynamicFileFd);
+            continue;
+        }
+
+        dynamicFileSz = dynamicFileStat.st_size;
+
+        uint8_t* dynamicFile = (uint8_t *) mmap(NULL, dynamicFileSz, PROT_READ | PROT_WRITE, MAP_SHARED, dynamicFileFd, 0);
+
+        if (dynamicFile == MAP_FAILED) {
+            PLOG_E("Error mapping dynamic input file: %s", dynamicInputFileName);
+            close(dynamicFileFd);
+            continue;
+        }
+
+        LOG_I("Loading dynamic input file: %s (%lu)", dynamicInputFileName, dynamicFileSz);
+
+        run_t my_run_t;
+        my_run_t.global = hfuzz;
+        dynfile_t dynfile = {
+            .size          = dynamicFileSz,
+            .cov           = {0xff, 0xff, 0xff, 0xff},
+            .idx           = 0,
+            .fd            = -1,
+            .timeExecUSecs = 1,
+            .path          = "",
+            .data          = dynamicFile,
+        };
+        my_run_t.timeStartedUSecs = util_timeNowUSecs() -1;
+        memcpy(dynfile.path, dynamicInputFileName, PATH_MAX);
+        my_run_t.dynfile = &dynfile;
+        input_addDynamicInput(&my_run_t);
+        // input_addDynamicInput(hfuzz, dynamicFile, dynamicFileSz, (uint64_t[4]){0xff, 0xff, 0xff, 0xff}, dynamicInputFileName);
+
+        /* Unmap input file. */
+        if (munmap((void *) dynamicFile, dynamicFileSz) == -1) {
+            PLOG_E("Error unmapping input file!");
+        }
+
+        /* Close input file. */
+        if (close(dynamicFileFd) == -1) {
+            PLOG_E("Error closing input file!");
+        }
+
+        /* Remove enqueued file from the directory. */
+        unlink(dynamicInputFileName);
+    }
+    closedir(dynamicDirPtr);
+}
+
+
 size_t input_getRandomInputAsBuf(run_t* run, const uint8_t** buf) {
     if (ATOMIC_GET(run->global->io.dynfileqCnt) == 0) {
         LOG_E("The dynamic input queue shouldn't be empty");
diff -ruN honggfuzz-2.3.1/input.h honggfuzz-2.3.1-pastis/input.h
--- honggfuzz-2.3.1/input.h	2020-07-22 18:04:55.000000000 -0300
+++ honggfuzz-2.3.1-pastis/input.h	2022-01-03 10:48:19.740187030 -0300
@@ -49,5 +49,7 @@
 extern bool   input_prepareExternalFile(run_t* run);
 extern bool   input_postProcessFile(run_t* run, const char* cmd);
 extern bool   input_prepareDynamicFileForMinimization(run_t* run);
+extern bool   input_dynamicQueueGetNext(char fname[PATH_MAX], DIR* dynamicDirPtr, char *dynamicWorkDir);
+extern void   input_enqueueDynamicInputs(honggfuzz_t* hfuzz);
 
 #endif /* ifndef _HF_INPUT_H_ */
