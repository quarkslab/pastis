diff -ruN honggfuzz-2.1/cmdline.c honggfuzz-2.1-pastis/cmdline.c
--- honggfuzz-2.1/cmdline.c	2020-03-02 20:35:20.000000000 -0300
+++ honggfuzz-2.1-pastis/cmdline.c	2022-01-03 10:51:07.688436792 -0300
@@ -477,6 +477,9 @@
         { { "only_printable", no_argument, NULL, 0x10D }, "Only generate printable inputs" },
         { { "export_feedback", no_argument, NULL, 0x10E }, "Export the coverage feedback structure as ./hfuzz-feedback" },
         { { "experimental_const_feedback", required_argument, NULL, 0x112 }, "*** EXPERIMENTAL *** Use constant integer/string values from fuzzed programs to mangle input files (default: false)" },
+        { { "statsfile", required_argument, NULL, 0x113 }, "Stats file" },
+        { { "dynamic_input", required_argument, NULL, 0x114 }, "Path to a directory containing the dynamic file corpus" },
+        { { "custom_mutator", required_argument, NULL, 0x115 }, "Custom mutator" },
 
 #if defined(_HF_ARCH_LINUX)
         { { "linux_symbols_bl", required_argument, NULL, 0x504 }, "Symbols blacklist filter file (one entry per line)" },
@@ -732,6 +735,15 @@
                 hfuzz->netbsd.symsWlFile = optarg;
                 break;
 #endif /* defined(_HF_ARCH_NETBSD) */
+            case 0x113:
+                hfuzz->io.statsFileName = optarg;
+                break;
+            case 0x114:
+                hfuzz->io.dynamicInputDir = optarg;
+                break;
+            case 0x115:
+                hfuzz->mutate.customMutatorFileName = optarg;
+                break;
             default:
                 cmdlineUsage(argv[0], custom_opts);
                 return false;
diff -ruN honggfuzz-2.1/fuzz.c honggfuzz-2.1-pastis/fuzz.c
--- honggfuzz-2.1/fuzz.c	2020-03-02 20:35:20.000000000 -0300
+++ honggfuzz-2.1-pastis/fuzz.c	2022-01-03 10:51:07.720436832 -0300
@@ -232,6 +232,39 @@
                 run->global->linux.hwCnts.bbCnt, run->global->linux.hwCnts.softCntEdge,
                 run->global->linux.hwCnts.softCntPc, run->global->linux.hwCnts.softCntCmp);
 
+            if (run->global->io.statsFileName) {
+                /* NOTE: Calculation of `tot_exec_per_sec` taken from
+                 * the `display_display` function.
+                 */
+                const time_t curr_sec = time(NULL);
+                const time_t elapsed_sec = curr_sec - run->global->timing.timeStart;
+                size_t curr_exec_cnt = ATOMIC_GET(run->global->cnts.mutationsCnt);
+                /*
+                 * We increase the mutation counter unconditionally in threads, but if it's
+                 * above hfuzz->mutationsMax we don't really execute the fuzzing loop.
+                 * Therefore at the end of fuzzing, the mutation counter might be higher
+                 * than hfuzz->mutationsMax
+                 */
+                if (run->global->mutate.mutationsMax > 0 && curr_exec_cnt > run->global->mutate.mutationsMax) {
+                    curr_exec_cnt = run->global->mutate.mutationsMax;
+                }
+                size_t tot_exec_per_sec = elapsed_sec ? (curr_exec_cnt / elapsed_sec) : 0;
+
+                dprintf(run->global->io.statsFileFd,
+                    "%lu, %lu, %lu, %lu, "
+                    "%" PRIu64 ", %" PRIu64 ", %" PRIu64 ", %" PRIu64 ", %" PRIu64 "\n",
+                    curr_sec,                                               /* unix_time */
+                    ATOMIC_GET(run->global->timing.lastCovUpdate),          /* last_cov_update */
+                    curr_exec_cnt,                                          /* total_exec */
+                    tot_exec_per_sec,                                       /* exec_per_sec */
+                    ATOMIC_GET(run->global->cnts.crashesCnt),               /* crashes */
+                    ATOMIC_GET(run->global->cnts.uniqueCrashesCnt),         /* unique_crashes */
+                    ATOMIC_GET(run->global->cnts.timeoutedCnt),             /* hangs */
+                    ATOMIC_GET(run->global->linux.hwCnts.softCntEdge),      /* edge_cov */
+                    ATOMIC_GET(run->global->linux.hwCnts.softCntPc)         /* block_cov */
+                );
+            }
+
             input_addDynamicInput(run->global, run->dynamicFile, run->dynamicFileSz,
                 (uint64_t[4]){0, 0, 0, 0}, "[DYNAMIC]");
         }
diff -ruN honggfuzz-2.1/honggfuzz.c honggfuzz-2.1-pastis/honggfuzz.c
--- honggfuzz-2.1/honggfuzz.c	2020-03-02 20:35:20.000000000 -0300
+++ honggfuzz-2.1-pastis/honggfuzz.c	2022-01-03 10:51:07.724436838 -0300
@@ -22,7 +22,9 @@
  *
  */
 
+#include <dlfcn.h>
 #include <errno.h>
+#include <fcntl.h>
 #include <getopt.h>
 #include <inttypes.h>
 #include <signal.h>
@@ -31,6 +33,7 @@
 #include <string.h>
 #include <sys/mman.h>
 #include <sys/resource.h>
+#include <sys/stat.h>
 #include <sys/time.h>
 #include <time.h>
 #include <unistd.h>
@@ -262,6 +265,12 @@
     setupMainThreadTimer();
 
     for (;;) {
+        /* Dynamic input queue. */
+        if (hfuzz->io.dynamicInputDir) {
+            LOG_D("Loading files from the dynamic input queue...");
+            input_enqueueDynamicInputs(hfuzz);
+        }
+
         if (hfuzz->display.useScreen) {
             if (ATOMIC_XCHG(clearWin, false)) {
                 display_clear();
@@ -373,6 +382,32 @@
                 sizeof(cmpfeedback_t), hfuzz.io.workDir);
         }
     }
+    /* Stats file. */
+    if (hfuzz.io.statsFileName) {
+        hfuzz.io.statsFileFd = TEMP_FAILURE_RETRY(open(hfuzz.io.statsFileName, O_CREAT | O_RDWR | O_TRUNC, 0640));
+
+        if (hfuzz.io.statsFileFd == -1) {
+            PLOG_F("Couldn't open statsfile open('%s')", hfuzz.io.statsFileName);
+        } else {
+            dprintf(hfuzz.io.statsFileFd, "# unix_time, last_cov_update, total_exec, exec_per_sec, crashes, unique_crashes, hangs, edge_cov, block_cov\n");
+        }
+    }
+    /* Custom mutator. */
+    if (hfuzz.mutate.customMutatorFileName) {
+        LOG_I("Loading custom mutator library");
+
+        hfuzz.mutate.customMutatorLibHandler = dlopen(hfuzz.mutate.customMutatorFileName, RTLD_NOW);
+
+        if (!hfuzz.mutate.customMutatorLibHandler) {
+            LOG_F("Error loading custom mutator library!");
+        } else {
+            hfuzz.mutate.customMutatorFunction = (customMutator_t) dlsym(hfuzz.mutate.customMutatorLibHandler, "custom_mutator");
+
+            if (!hfuzz.mutate.customMutatorFunction) {
+                LOG_F("Error loading custom mutator function!");
+            }
+        }
+    }
 
     setupRLimits();
     setupSignalsPreThreads();
@@ -410,6 +445,20 @@
     if (hfuzz.socketFuzzer.enabled) {
         cleanupSocketFuzzer();
     }
+    /* Stats file. */
+    if (hfuzz.io.statsFileName) {
+        close(hfuzz.io.statsFileFd);
+    }
+    /* Custom mutator. */
+    if (hfuzz.mutate.customMutatorLibHandler) {
+        LOG_I("Unloading custom mutator library");
+
+        if (dlclose(hfuzz.mutate.customMutatorLibHandler) != 0) {
+            LOG_E("Error unloading custom mutator library.");
+        } else {
+            hfuzz.mutate.customMutatorFunction = NULL;
+        }
+    }
 
     printSummary(&hfuzz);
 
diff -ruN honggfuzz-2.1/honggfuzz.h honggfuzz-2.1-pastis/honggfuzz.h
--- honggfuzz-2.1/honggfuzz.h	2020-03-02 20:35:20.000000000 -0300
+++ honggfuzz-2.1-pastis/honggfuzz.h	2022-01-03 10:51:07.732436848 -0300
@@ -102,6 +102,8 @@
 /* HF NetDriver signature - if found within file, it means it's a NetDriver-based binary */
 #define _HF_NETDRIVER_SIG "\x01_LIBHFUZZ_NETDRIVER_BINARY_SIGNATURE_\x02\xFF"
 
+typedef void (*customMutator_t)(uint8_t data[], size_t size);
+
 typedef enum {
     _HF_DYNFILE_NONE = 0x0,
     _HF_DYNFILE_INSTR_COUNT = 0x1,
@@ -220,6 +222,9 @@
         struct dynfile_t* dynfileqCurrent;
         TAILQ_HEAD(dyns_t, dynfile_t) dynfileq;
         bool exportFeedback;
+        const char* statsFileName;
+        int statsFileFd;
+        const char* dynamicInputDir;
     } io;
     struct {
         int argc;
@@ -256,6 +261,9 @@
         size_t mutationsMax;
         unsigned mutationsPerRun;
         size_t maxFileSz;
+        const char* customMutatorFileName;
+        void* customMutatorLibHandler;
+        customMutator_t customMutatorFunction;
     } mutate;
     struct {
         bool useScreen;
diff -ruN honggfuzz-2.1/input.c honggfuzz-2.1-pastis/input.c
--- honggfuzz-2.1/input.c	2020-03-02 20:35:20.000000000 -0300
+++ honggfuzz-2.1-pastis/input.c	2022-01-03 10:51:07.732436848 -0300
@@ -564,3 +564,110 @@
 
     return true;
 }
+
+/**
+ * NOTE: This function is based on `input_getNext`.
+ */
+bool input_dynamicQueueGetNext(char fname[PATH_MAX], DIR* dynamicDirPtr, char *dynamicWorkDir) {
+    static pthread_mutex_t input_mutex = PTHREAD_MUTEX_INITIALIZER;
+    MX_SCOPED_LOCK(&input_mutex);
+
+    for (;;) {
+        errno = 0;
+        struct dirent* entry = readdir(dynamicDirPtr);
+        if (entry == NULL && errno == EINTR) {
+            continue;
+        }
+        if (entry == NULL && errno != 0) {
+            PLOG_W("readdir_r('%s')", dynamicWorkDir);
+            return false;
+        }
+        if (entry == NULL) {
+            return false;
+        }
+        char path[PATH_MAX];
+        snprintf(path, PATH_MAX, "%s/%s", dynamicWorkDir, entry->d_name);
+        struct stat st;
+        if (stat(path, &st) == -1) {
+            LOG_W("Couldn't stat() the '%s' file", path);
+            continue;
+        }
+        if (!S_ISREG(st.st_mode)) {
+            LOG_D("'%s' is not a regular file, skipping", path);
+            continue;
+        }
+
+        snprintf(fname, PATH_MAX, "%s/%s", dynamicWorkDir, entry->d_name);
+        return true;
+    }
+}
+
+void input_enqueueDynamicInputs(honggfuzz_t* hfuzz) {
+    char dynamicWorkDir[PATH_MAX];
+
+    snprintf(dynamicWorkDir, sizeof(dynamicWorkDir), "%s", hfuzz->io.dynamicInputDir);
+
+    int dynamicDirFd = TEMP_FAILURE_RETRY(open(dynamicWorkDir, O_DIRECTORY | O_RDONLY | O_CLOEXEC));
+    if (dynamicDirFd == -1) {
+        PLOG_W("open('%s', O_DIRECTORY|O_RDONLY|O_CLOEXEC)", dynamicWorkDir);
+        return;
+    }
+
+    DIR* dynamicDirPtr;
+    if ((dynamicDirPtr = fdopendir(dynamicDirFd)) == NULL) {
+        PLOG_W("fdopendir(dir='%s', fd=%d)", dynamicWorkDir, dynamicDirFd);
+        close(dynamicDirFd);
+        return;
+    }
+
+    char dynamicInputFileName[PATH_MAX];
+    for (;;) {
+        if (!input_dynamicQueueGetNext(dynamicInputFileName, dynamicDirPtr, dynamicWorkDir)) {
+            break;
+        }
+
+        int dynamicFileFd;
+        if ((dynamicFileFd = open(dynamicInputFileName, O_RDWR)) == -1) {
+            PLOG_E("Error opening dynamic input file: %s", dynamicInputFileName);
+            continue;
+        }
+
+        /* Get file status. */
+        struct stat dynamicFileStat;
+        size_t dynamicFileSz;
+
+        if (fstat(dynamicFileFd, &dynamicFileStat) == -1) {
+            PLOG_E("Error getting file status: %s", dynamicInputFileName);
+            close(dynamicFileFd);
+            continue;
+        }
+
+        dynamicFileSz = dynamicFileStat.st_size;
+
+        uint8_t* dynamicFile = (uint8_t *) mmap(NULL, dynamicFileSz, PROT_READ | PROT_WRITE, MAP_SHARED, dynamicFileFd, 0);
+
+        if (dynamicFile == MAP_FAILED) {
+            PLOG_E("Error mapping dynamic input file: %s", dynamicInputFileName);
+            close(dynamicFileFd);
+            continue;
+        }
+
+        LOG_I("Loading dynamic input file: %s (%lu)", dynamicInputFileName, dynamicFileSz);
+
+        input_addDynamicInput(hfuzz, dynamicFile, dynamicFileSz, (uint64_t[4]){0xff, 0xff, 0xff, 0xff}, dynamicInputFileName);
+
+        /* Unmap input file. */
+        if (munmap((void *) dynamicFile, dynamicFileSz) == -1) {
+            PLOG_E("Error unmapping input file!");
+        }
+
+        /* Close input file. */
+        if (close(dynamicFileFd) == -1) {
+            PLOG_E("Error closing input file!");
+        }
+
+        /* Remove enqueued file from the directory. */
+        unlink(dynamicInputFileName);
+    }
+    closedir(dynamicDirPtr);
+}
diff -ruN honggfuzz-2.1/input.h honggfuzz-2.1-pastis/input.h
--- honggfuzz-2.1/input.h	2020-03-02 20:35:20.000000000 -0300
+++ honggfuzz-2.1-pastis/input.h	2022-01-03 10:51:07.736436852 -0300
@@ -44,4 +44,7 @@
 extern bool input_postProcessFile(run_t* run, const char* cmd);
 extern bool input_prepareDynamicFileForMinimization(run_t* run);
 
+extern bool input_dynamicQueueGetNext(char fname[PATH_MAX], DIR* dynamicDirPtr, char *dynamicWorkDir);
+extern void input_enqueueDynamicInputs(honggfuzz_t* hfuzz);
+
 #endif /* ifndef _HF_INPUT_H_ */
diff -ruN honggfuzz-2.1/Makefile honggfuzz-2.1-pastis/Makefile
--- honggfuzz-2.1/Makefile	2020-03-02 20:35:20.000000000 -0300
+++ honggfuzz-2.1-pastis/Makefile	2022-01-03 10:51:07.684436786 -0300
@@ -27,7 +27,7 @@
 HFUZZ_CC_BIN := hfuzz_cc/hfuzz-cc
 HFUZZ_CC_SRCS := hfuzz_cc/hfuzz-cc.c
 COMMON_CFLAGS := -std=c11 -I/usr/local/include -D_GNU_SOURCE -Wall -Wextra -Werror -Wno-format-truncation -Wno-override-init -I.
-COMMON_LDFLAGS := -pthread -lm
+COMMON_LDFLAGS := -pthread -lm -ldl
 COMMON_SRCS := $(sort $(wildcard *.c))
 CFLAGS ?= -O3 -mtune=native -funroll-loops
 LDFLAGS ?=
diff -ruN honggfuzz-2.1/mangle.c honggfuzz-2.1-pastis/mangle.c
--- honggfuzz-2.1/mangle.c	2020-03-02 20:35:20.000000000 -0300
+++ honggfuzz-2.1-pastis/mangle.c	2022-01-03 10:51:07.756436877 -0300
@@ -26,6 +26,7 @@
 
 #include <inttypes.h>
 #include <math.h>
+#include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -643,6 +644,13 @@
     mangle_Overwrite(run, (uint8_t*)buf, off, strlen(buf));
 }
 
+static void mangle_Custom(run_t* run, bool printable HF_ATTR_UNUSED) {
+    if (run->global->mutate.customMutatorFunction) {
+        LOG_D("Running custom mutator...");
+        run->global->mutate.customMutatorFunction(run->dynamicFile, run->dynamicFileSz);
+    }
+}
+
 void mangle_mangleContent(run_t* run) {
     static void (*const mangleFuncs[])(run_t * run, bool printable) = {
         mangle_Bit,
@@ -670,6 +678,12 @@
 
     mangle_Resize(run, /* printable= */ run->global->cfg.only_printable);
 
+    /* Custom mutator. */
+    if (run->global->mutate.customMutatorFunction) {
+        mangle_Custom(run, /* printable= */ run->global->cfg.only_printable);
+        return;
+    }
+
     /* Max number of stacked changes is, by default, 6 */
     uint64_t changesCnt = util_rndGet(1, run->global->mutate.mutationsPerRun);
     for (uint64_t x = 0; x < changesCnt; x++) {
